[
  
  {
    "title": "[Backend - Springboot] 백엔드 서버 배포 및 ci-cd",
    "url": "/posts/backend-cicd/",
    "categories": "Backend, Springboot",
    "tags": "",
    "date": "2025-02-01 03:00:00 +0900",
    





    
    "snippet": "1. 기본 서버 세팅 aws 인스턴스 생성 펨키는 이때 밖에 다운로드 못하니 잘 간직하기참고) 사진에는 handali-key가 펨키인데, 해당 인스턴스 지우고 다시 만들어서 handali-app-key라는 새로운 팸키를 사용중임인스턴스 유형 잘 고려해서 선택하기, 무료로 제공하는 건 정말 간단한 프로젝트에서만 사용 가능, 현재는 t2.medium 사용...",
    "content": "1. 기본 서버 세팅 aws 인스턴스 생성 펨키는 이때 밖에 다운로드 못하니 잘 간직하기참고) 사진에는 handali-key가 펨키인데, 해당 인스턴스 지우고 다시 만들어서 handali-app-key라는 새로운 팸키를 사용중임인스턴스 유형 잘 고려해서 선택하기, 무료로 제공하는 건 정말 간단한 프로젝트에서만 사용 가능, 현재는 t2.medium 사용중 (인스턴스만 몇 번을 중지했다 시작했다, 없앴다 만들었는 지 모름 ㅎ)서버에 접속퍼블릭 IPv4 주소: 43.201.250.84펨키 파일 명 : handali-app-key.pemchmod 400 handali-app-key.pemssh -i handali-app-key.pem ubuntu@43.201.250.84스프링부트 실행을 위해 필요한 파일 다운로드(기초작업)sudo apt updatesudo apt install openjdk-17-jdk -ysudo apt install git -y1) mysql 설치 및 설정//설치 및 실행sudo apt install mysql-server -ysudo systemctl start mysqlsudo systemctl status mysql //active 상태 인지 확인//보안 설정(안해도 됨)sudo mysql_secure_installatio//사용자 설정sudo mysql -u root -p //mysql 루트 계정으로 실행, 첫 비밀번호는 엔터ALTER USER 'root'@'localhost' IDENTIFIED WITH 'mysql_native_password' BY 'Hyeon01!m'; //루트 비밀번호 변경CREATE USER 'handali_user'@'%' IDENTIFIED BY 'Handali1234!'; //새로운 사용자 등록(스프링부트 서버에서 사용함)GRANT ALL PRIVILEGES ON handali_db.* TO 'handali_user'@'%'; //권한 부여SELECT user, host FROM mysql.user; //사용자 생성된 것 확인FLUSH PRIVILEGES; //위의 설정들을 적용//테이블 생성(스프링부트 서버에서 사용하는 테이블명과 일치)create database handali_db;show databases; //생성된 것 확인2) redis 설치 및 설정sudo apt install redis-server -ysudo systemctl start redis sudo systemctl status redis //active 상태 인지 확인3) nginx 설치 및 설정sudo apt install nginx -ysudo nano /etc/nginx/sites-available/default아래 내용 입력 - ip주소:80 으로 요청한 내용을 localhost:8080으로 변환해줌server {    listen 80;    server_name yourdomain.com; # 도메인을 설정하거나 EC2 퍼블릭 IP 사용    location / {        proxy_pass http://localhost:8080; # Spring Boot가 실행 중인 포트        proxy_set_header Host $host;        proxy_set_header X-Real-IP $remote_addr;        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        proxy_set_header X-Forwarded-Proto $scheme;    }}nginx 재시작sudo systemctl restart nginx 서버 설정 완료 2. ci/cd 없이 개발 할 경우,,,,(기초)(매우 번거로워서 비추)(근데 ci/cd yml 파일에 이 내용을 기반으로 작성하긴 함)1) 빌드 및 빌드 파일 있는 폴더로 이동./gradlew build //가장 처음 빌드 할때 ./gradlew clean build //처음 이후로 빌드 할때.jar 파일이 있는 폴더로 이동cd build/libs2) 서버에 .jar 파일 올리기scp -i [펨키 경로] [jar 파일 경로] ubuntu@[ip 주소] : [원격 저장소 경로(내맘대로지정)]  command + option + c : 파일 경로 복사 단축키3) 서버에 접속 후, jar 파일 실행오류 없이 잘 동작하나 확인하기, 종료는 control+cjava -jar handali-0.0.1-SNAPSHOT.jar 이후, 백그라운드 실행nohup java -jar handali-0.0.1-SNAPSHOT.jar &gt; application.log 2&gt;&amp;1 &amp; +) 프로세스 종료백그라운드에서 실행 중인지 확인 할 수 있고, 해당 프로세서의 pid 확인가능ps aux | grep java프로세스 종료kill -9 {pid}코드가 수정 되었다면, 프로세스 종료 후, 1~3번 과정을 다시 반복해야 함..ㅎㅎ백엔드 코드 배포 완료3. ci/cd 셋팅1) 서버 접속 후, 깃허브 리포지토리 클론ssh -i {pem key} ubuntu@{ip}git clone https://github.com/ParkJangHa/handali_back.git2) ssh 키 생성 및 깃허브 액션에 키 등록2-1) 키 생성(‘로컬’에서 생성)ssh-keygen -t rsa -b 4096 -C \"github-actions\" -f ~/.ssh/github-actions -N \"\"Your identification has been saved in /home/ubuntu/.ssh/github-actions (개인 키, 깃허브액션에서 사용)Your public key has been saved in /home/ubuntu/.ssh/github-actions.pub(공개 키, ec2에 등록)The key fingerprint is:SHA256:cmpaL0HKv28fEcnP1Iyd4fiPoaljgRrKoxO/Wn8p6wo github-actionsThe key's randomart image is:2-2) 공개 키 출력 및 복사하고,cat ~/.ssh/github-actions.pub  공개키ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDAJxfBLHAPUdIlKQlnIKaI/rJT0aTswZGvwIPBjaJkHvSojJA/rShsQlDcKf/ROnAci2Ql3gXRZLSAV2LhOi9Y9LAFchN2mIu2vD1reYI1sKS3GtjjDlnrBtd54yJ0VJxIdPtceTCqxEQkbmgQ7dBj1NeN4ZGaPRfLWZxiQeC7mbxczk+iscIPImzhrV/M4N5oV0fFRqmzdkgX8f4ckKVWE2oj1iyY6V+KmdvEF3UBj4JK0JPf/Cy5E/KjDQRuG1e8iJgHRb8PzjfSCnIfZwfp6wEk1VNqePkV5f9p2KwDC4sPyCYz4NwQzxIXDzOPWzS/zBDi7sx/Lae/5FlhslqWiqm+kgjtAPXH7B42X8EE3Vi/Dz8rDjJy64CqjWLIkmsdBk7mBA0M6LD9oD3BGsPlxmq0249VrfLaN0jMwRQEmnRciSg58wSGm2u2lgQL6MvOwURDu6mMjIGvzLsbuO4knfkP91B5WNKdU3IxtY6gBLn8rWXhQ++F9UvBCp3FQjNQ6ykc/JNoOR/hv68hXhnpDapcgT1kWcnbtus96R3HCqWiGnrY+0cFu9VS5eeWc6mgAjt8IMgKX1KZz7tHw4pFOkk1jQcUQuqLG/REYR7dVQjj4797gnPABgqOiTpSZithQsvEHTY8hlRdANToB+n0R2lXOZNegP8ccom0fd75BQ== github-actions\" &gt;&gt; ~/.ssh/authorized_keys서버에 접속 후, 공개 키를 ec2 서버에 등록ssh -i {pem key} ubuntu@{ip}echo \"공개키\" &gt;&gt; ~/.ssh/authorized_keyschmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys참고) 공개키를 서버에 등록했으므로, 앞으로는 개인 키로도 서버에 접속이 가능해짐ssh -i ~/.ssh/github-actions ubuntu@43.201.250.842-3) 개인 키 출력(로컬 환경)하고,cat ~/.ssh/github-actions출력된 키 형식-----BEGIN OPENSSH PRIVATE KEY-----...-----END OPENSSH PRIVATE KEY-----깃허브에 등록깃허브 리포지토리 &gt; settings &gt; secrets and variables &gt; actions &gt; new repository secret - ssh key 등록 \t제목 : AWS_SSH_KEY\t내용 : 복사한 개인 키 - host 등록\t제목: AWS_HOST\t내용: EC2 퍼블릭 Ip호스트와 키를 등록함으로써, 깃허브 액션이 ssh로 해당 호스트에 키를 가지고 접근할 수 있어짐ssh -i ~/.ssh/github-actions ubuntu@43.201.250.84 위에 참고로 달아둔, 이 접근을 하는 것임**ssh: handshake failed: ssh: unable to authenticate, attempted methods [none publickey], no supported methods remain** 에러해결법sudo nano /etc/ssh/sshd_config //ssh 설정 파일 열기//4줄 추가PermitRootLogin prohibit-passwordPasswordAuthentication noPubkeyAuthentication yesPubkeyAcceptedKeyTypes +ssh-rsasudo systemctl restart ssh //재시작sudo systemctl status ssh //active 이면 성공3) 깃허브 액션 워크플로우 파일 작성로컬 환경에서 리포지토리의 루트 경로로 터미널 열기(.git 파일 있는 경로), 루트 경로에 아래의 파일이 생성 되어야 함mkdir -p .github/workflowsnano .github/workflows/deploy.yml.github/workflows/deploy.yml 파일 내용name: Deploy to AWS EC2on:  push:    branches:      - main  # main 브랜치에 Push될 때 실행jobs:  deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout Repository        uses: actions/checkout@v3      - name: Deploy to EC2        uses: appleboy/ssh-action@v0.1.4        with:          host: $          username: ubuntu          key: $          script: |                        # 1. main 브랜치 코드 가져오기             cd /home/ubuntu/handali_back             git pull origin main                                    # 2. 코드 빌드하기            cd handali             ./gradlew clean build                                    # 3. 권한 설정하기            chmod +x gradlew             # 4. 기존 애플리케이션 프로세스 종료 (PID 파일을 이용)            if [ -f app.pid ]; then              old_pid=$(cat app.pid)              echo \"Stopping existing process with PID $old_pid\"              kill -9 $old_pid || true              sleep 2              rm -f app.pid            fi                                    #4. 빌드된 파일 백그라운드 실행하기            echo \"==== Running application in background ====\"            setsid java -jar build/libs/handali-0.0.1-SNAPSHOT.jar &gt; app.log 2&gt;&amp;1 &amp;            echo $! &gt; app.pid                        echo \"==== Deployment Finished! ====\"yml 파일을 원격 저장소에 푸시 git add .github/workflows/deploy.yml  git commit -m \"Add GitHub Actions workflow for deployment\" git push origin main 4) main에 푸시할 경우, 자동으로 배포가 되는지 확인내용 수정 이후,git add .git commit -m \"자동배포 테스트\"git push origin main깃허브 액션에서 확인가능작동 중인 java -jar 프로세서가 있는 지 확인하고, 포스트맨으로 요청 날렸을 때 정상 동작 하면 성공!ps aux | grep java(혹은, 서버에 접속해서 내용 수정한 부분이 제대로 적용 되었나 확인 해봐도 됨)ci/cd 환경 구성 완료"
  },
  
  {
    "title": "[Git&GitHub - 기본개념] 이전 커밋으로 돌아가기_reset,revert",
    "url": "/posts/git-revert/",
    "categories": "Git&GitHub, 기본개념",
    "tags": "",
    "date": "2025-01-15 14:10:00 +0900",
    





    
    "snippet": "Reset커밋 히스토리를 되돌리고, 특정 커밋 시점의 상태로 돌아가게 함  git log : 돌아갈 커밋의 해시를 복사        git reset --hard {돌아갈 커밋의 해시} : 해당 커밋을 했던 시점의 코드로 변경됨, 해당 커밋 이후의 커밋은 사라짐(초기화)     -- hard: working directory의 변경 사항도 모두 초기화...",
    "content": "Reset커밋 히스토리를 되돌리고, 특정 커밋 시점의 상태로 돌아가게 함  git log : 돌아갈 커밋의 해시를 복사        git reset --hard {돌아갈 커밋의 해시} : 해당 커밋을 했던 시점의 코드로 변경됨, 해당 커밋 이후의 커밋은 사라짐(초기화)     -- hard: working directory의 변경 사항도 모두 초기화 -- soft: 커밋만 되돌리고, staging area&amp;working directory는 유지 -- mixed: 커밋&amp;staging area 되돌리고, working directory는 유지      Revert특정 커밋을 되돌리되, 기존 커밋 히스토리를 보존하면서 새로운 커밋을 생성  git log : 취소하고 싶은 커밋의 해시를 복사  git revert {특정 커밋 해시} : 특정  커밋의 변경 사항을 되돌리는 새로운 커밋을 생성협업 중인 프로젝트에서 안전하게 커밋을 되돌릴때 사용Revert 실습 실습 목표첫번째 커밋: a.txt 파일 생성 \"나는 첫번째 글\" 추가두번째 커밋: a.txt 파일 \"나는 두번째 글\" 추가세번째 커밋: a.txt 파일 \"나는 세번째 글\" 추가네번째 커밋: b.txt 파일 생성 \"1\" 추가두번째 커밋으로 revert 했을 때, 결과는 ??  첫번째 커밋          git add .      git commit -m \"first\"        두번째 커밋          git add .      git commit -m \"add second line\"        세번째 커밋          git add .      git commit -m \"add third line\"        네번째 커밋          git add .      git commit -m \"add b.txt\"        두번째 커밋으로 revert          git log : 두번째 커밋의 해시값 얻기      git revert d3256309b1f4d45d01d : 두번째 커밋의 해시값 일부 복사하여 revert         결과두번째 커밋의 변경 사항을 되돌리는 것이기 때문에 \"나는 첫번째 글\" 만 남는다b.txt 파일의 변경사항은 두번째 커밋과 관련이 없기 때문에 제거되지 않고 남아있게 된다."
  },
  
  {
    "title": "[Old Blog] 네이버 블로그",
    "url": "/posts/oldblog/",
    "categories": "Old Blog",
    "tags": "",
    "date": "2025-01-09 18:10:00 +0900",
    





    
    "snippet": "https://blog.naver.com/hada0413/",
    "content": "https://blog.naver.com/hada0413/"
  },
  
  {
    "title": "[Algorithm - 이론] 이분탐색(이진탐색)",
    "url": "/posts/algorithm-binarysearch/",
    "categories": "Algorithm, 이론",
    "tags": "",
    "date": "2025-01-09 15:10:00 +0900",
    





    
    "snippet": "기본 개념  배열 내부의 값이 정렬이 되어 있을 때 사용 가능하다  변수 3개(start, mid, end)를 이용하여 원하는 값을 찾는 알고리즘 이다  시간복잡도: O(logN), n은 이분 탐색을 진행하는 리스트의 크기반복문을 이용한 구현def binarySearch(array, start, end, k):    while start &lt;= e...",
    "content": "기본 개념  배열 내부의 값이 정렬이 되어 있을 때 사용 가능하다  변수 3개(start, mid, end)를 이용하여 원하는 값을 찾는 알고리즘 이다  시간복잡도: O(logN), n은 이분 탐색을 진행하는 리스트의 크기반복문을 이용한 구현def binarySearch(array, start, end, k):    while start &lt;= end:        mid = (start + end) // 2        if array[mid] == k:            return mid        elif array[mid] &gt; k:            end = mid - 1        else:            start = mid + 1    else:        return False나만의 팁1. 이분탐색 문제 구별법문제에 입력 값이 매우 큰 수가 나오는 경우가 많은데, 문제 자체가 완전 탐색으로 풀면 풀릴 것 같은 느낌이 듬2. 문제 접근법      이분 탐색으로 풀어야 한다고 판단이 되면,    출력값에 대한 범위를 구해보기 = start, end 에 가능한 값이 무엇일까 생각해보기 ‘출력될 수 있는 최소의 값 ~ 출력될 수 있는 최대의 값’ 이 범위에서 이분 탐색을 진행한다고 생각하기        범위가 구해지면, 문제 조건에 맞게 범위의 값을 조절하기    (백준의 경우 이 부분이 문제 레벨에 따라 난이도가 갈리는 듯,’나무자르기-실버’의 경우 이 부분이 쉽게 생각나고, ‘공유기설치-골드’의 경우 이 부분이 어려웠음)  "
  }
  
]

