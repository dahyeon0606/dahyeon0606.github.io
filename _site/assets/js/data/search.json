[
  
  {
    "title": "[Git&GitHub - 기본개념] 이전 커밋으로 돌아가기_reset,revert",
    "url": "/posts/git-revert/",
    "categories": "Git&GitHub, 기본개념",
    "tags": "",
    "date": "2025-01-15 14:10:00 +0900",
    





    
    "snippet": "Reset커밋 히스토리를 되돌리고, 특정 커밋 시점의 상태로 돌아가게 함  git log : 돌아갈 커밋의 해시를 복사        git reset --hard {돌아갈 커밋의 해시} : 해당 커밋을 했던 시점의 코드로 변경됨, 해당 커밋 이후의 커밋은 사라짐(초기화)     -- hard: working directory의 변경 사항도 모두 초기화...",
    "content": "Reset커밋 히스토리를 되돌리고, 특정 커밋 시점의 상태로 돌아가게 함  git log : 돌아갈 커밋의 해시를 복사        git reset --hard {돌아갈 커밋의 해시} : 해당 커밋을 했던 시점의 코드로 변경됨, 해당 커밋 이후의 커밋은 사라짐(초기화)     -- hard: working directory의 변경 사항도 모두 초기화 -- soft: 커밋만 되돌리고, staging area&amp;working directory는 유지 -- mixed: 커밋&amp;staging area 되돌리고, working directory는 유지      Revert특정 커밋을 되돌리되, 기존 커밋 히스토리를 보존하면서 새로운 커밋을 생성  git log : 취소하고 싶은 커밋의 해시를 복사  git revert {특정 커밋 해시} : 특정  커밋의 변경 사항을 되돌리는 새로운 커밋을 생성협업 중인 프로젝트에서 안전하게 커밋을 되돌릴때 사용Revert 실습 실습 목표첫번째 커밋: a.txt 파일 생성 \"나는 첫번째 글\" 추가두번째 커밋: a.txt 파일 \"나는 두번째 글\" 추가세번째 커밋: a.txt 파일 \"나는 세번째 글\" 추가네번째 커밋: b.txt 파일 생성 \"1\" 추가두번째 커밋으로 revert 했을 때, 결과는 ??  첫번째 커밋          git add .      git commit -m \"first\"        두번째 커밋          git add .      git commit -m \"add second line\"        세번째 커밋          git add .      git commit -m \"add third line\"        네번째 커밋          git add .      git commit -m \"add b.txt\"        두번째 커밋으로 revert          git log : 두번째 커밋의 해시값 얻기      git revert d3256309b1f4d45d01d : 두번째 커밋의 해시값 일부 복사하여 revert         결과두번째 커밋의 변경 사항을 되돌리는 것이기 때문에 \"나는 첫번째 글\" 만 남는다b.txt 파일의 변경사항은 두번째 커밋과 관련이 없기 때문에 제거되지 않고 남아있게 된다."
  },
  
  {
    "title": "[Old Blog] 네이버 블로그",
    "url": "/posts/oldblog/",
    "categories": "Old Blog",
    "tags": "",
    "date": "2025-01-09 18:10:00 +0900",
    





    
    "snippet": "https://blog.naver.com/hada0413/",
    "content": "https://blog.naver.com/hada0413/"
  },
  
  {
    "title": "[Algorithm - 이론] 이분탐색(이진탐색)",
    "url": "/posts/algorithm-binarysearch/",
    "categories": "Algorithm, 이론",
    "tags": "",
    "date": "2025-01-09 15:10:00 +0900",
    





    
    "snippet": "기본 개념  배열 내부의 값이 정렬이 되어 있을 때 사용 가능하다  변수 3개(start, mid, end)를 이용하여 원하는 값을 찾는 알고리즘 이다  시간복잡도: O(logN), n은 이분 탐색을 진행하는 리스트의 크기반복문을 이용한 구현def binarySearch(array, start, end, k):    while start &lt;= e...",
    "content": "기본 개념  배열 내부의 값이 정렬이 되어 있을 때 사용 가능하다  변수 3개(start, mid, end)를 이용하여 원하는 값을 찾는 알고리즘 이다  시간복잡도: O(logN), n은 이분 탐색을 진행하는 리스트의 크기반복문을 이용한 구현def binarySearch(array, start, end, k):    while start &lt;= end:        mid = (start + end) // 2        if array[mid] == k:            return mid        elif array[mid] &gt; k:            end = mid - 1        else:            start = mid + 1    else:        return False나만의 팁1. 이분탐색 문제 구별법문제에 입력 값이 매우 큰 수가 나오는 경우가 많은데, 문제 자체가 완전 탐색으로 풀면 풀릴 것 같은 느낌이 듬2. 문제 접근법      이분 탐색으로 풀어야 한다고 판단이 되면,    출력값에 대한 범위를 구해보기 = start, end 에 가능한 값이 무엇일까 생각해보기 ‘출력될 수 있는 최소의 값 ~ 출력될 수 있는 최대의 값’ 이 범위에서 이분 탐색을 진행한다고 생각하기        범위가 구해지면, 문제 조건에 맞게 범위의 값을 조절하기    (백준의 경우 이 부분이 문제 레벨에 따라 난이도가 갈리는 듯,’나무자르기-실버’의 경우 이 부분이 쉽게 생각나고, ‘공유기설치-골드’의 경우 이 부분이 어려웠음)  "
  }
  
]

